gAAAAABfUliRdu30gwt87sFkAob0EespunqXlepMRThJOwFV4i3j4B2yIyrTP5GuWmYrXbjmXB9XjID960zKPRgf3WvfQ7CtIEe8cgBpYWBsO15wYHV2ArE5dfOdZA2oLA1698f0a-EE9C8JmCSFzVYgq343qtZuS8RxGIu6rsz_lvdJteKexrW4c8qupoptnUpZEInmJ22andbr5NwUHneIgTCJBua2SV0bfxOmTMK-2HQpkqOTaxzhpjSpQCk1rRzpdya7-QJ3vhc0dA82imX9eRsygbYgAfEvoFWCyVDLb0g2Mbo6QDDV3O6IYJQO7Lmdm9IlWSgKE5NDPW_Z5Xx2a3AF7t8-U6xIBzQmVwqr5kEgOqH9xCOQrzhjRdCnrFBHaQdrVhlsTLt7nzDeE_ic06_OopCzX7hiMLmvB2PTc5ALSmnvzFiuflvwWISF4PuLjmQdC4dEx19XQOIzwiZgshl5hbEL4VU523fI3l7PJ20Tws_ze1W6GQ8MAfMM5Sq9XBzBite4MARGDPqmHVIJIkTbO1j2UtFa168NAh8Ey1kJYwXVFhI33DmBiKGd0CkL1GqPe33mCc3H8JgGC_80RTtK-3CkDXiEAe_UNzoY05q1tUm76-63K3IeLorYLusfEHbbG6e-eD5e2YCgjzvP4MzoB3r7RfESslG6TAtX1uf3EJGxWZHjPWrRWzWyOTQtRR7ucBCyo_I7CfFoiAU2drZieqd3h_iBCJSC5N_dDWncSD7Jl6p3kCnYx-FD-59hNU4UXiY6th8iSm5Q9ztKW1B6U0ujZDQ8ddUbo40AUxnk9itGi0UxvwfYd__0sN404DDmLBifbLdGso23Z6U1W3CZ3tPZInbuNXDI88nFlGi-_rl2ACGVJv1M5V3F3GTclQGRX0itCmHX_pfwrdAR5zkzxw9spuh1ZWchUiz6BZjs_aceMjyXGKIZEKfdNm1-1FhA9lH5NoFKnuCEQW4V2c77D34heneVjjMJoJxjKa0QXaIADqP2GGmktvf98B59JYVqL8L19EKJvwxedHClhBuQqrzqTycZVHWhGii8flrZxkUq4QB6c_9-U98hOVZrocuzr4AmfXcWfPTZmmBKmhP0saRHsVk3ZLZP8qmBatrX2V9pWAq0lS2pnaUzzh8DkiZVXinVbOaRRoWBabSrS5Ve5IzQVFbL5H-WdoN7m3uCzz3fc3xoQe3J1JgRz7nhRNDj3Qdmw_J22mNMCvnpKIzVxT6nU5ma8Y7rUn-UY8r9CbnY59bOj-3yvZvWuiH9IUEnZPLJQUBx5v7yroph9BBhplSJiIyuLxHt0taNLO-mWW3Gn1NpHeHM8JorNO6Jea06v11YN3PzY-h3iDlZhwKLovVyWYY6wooMlJhBD4-ApJJuWM-6ldLt0eWB5__v57xKdFys6yuYRS4nwZNZqoUvX2KbYPrMHSrE_hGBi7L6oM8xtlCa83opn46Q8wci5asJKEr8MyuDgJ_tuMNQoqo3iUOtOZ8zf71SVrxW6aQdWau7iaGTn9G7zdyB21Rt9bRM_wX9L1YvuIrjhAJw1HQXY2zkfjIvzSgOtERK7ebxsEJ81Ao5yLsyWv07P1_rpswbU6EkJ2ZlDYjFZ9p48cUpkNSSAITtZSZGY2n_sw3gO-amvhgXnHSLHUgveFCxWKarsgvnSeIpBi_uGATnbuqiCcC2Z4oWxSx-m5FRIShPTdP6e2r7z3C-7nJAUTtknMsZDW6eSj3X2Qqnn70D1Iw7sWfI2WD3SaVDQk2PMASAeRFd8UU5gFYeq77piffRQ1zr1g_Mr0vpoF_eUlQ4NrXI6YDAEewM96w2brYbqiFQUApP0bKNRE6wFau7_emrCxE1Om7gtRKunmOlwNOCmdZFMzNioo1QDEP_Y7vFsMa-LWwxivKKnkRyUdEGACRo5IH7g-FK6rEAYvLuA418Od0-MtAMdgyywamlv2dnVz7rgmlDaBKqiwLRDahfrkv4Ce8wIpgmq5MudKiPSuEEAMQQdKJiKF-BiBXJK2QTtKHN7rCEMq_cuVZudLaK-Aw0FIrjg9jmB0AfNaLDD0vw1IH2zaqaP--vVYTaTe-5LjUw68ZWlW86cugK4RW5hHQ0tcAk_eHcAplsR8dnHo5s-PPFHnXK6Mf_QDqYi5dlO9Fsow5-km7YJ8nGa53ltHZK8fPcYgmKlu2-_XlUkxvbtWOwR_tl3v6KyC80svKTUAyMVnH4OLOjpzGwzTC057FLzF6W9hzqcNe9OHgAfj-8ZCMwFG4rBVIgwm8leKizXLR-XJu0lv1wzXmEtgMdnkTZvth1VR9CQ2BhQLjmCdBVCEyRlO_id33da4f6MxvTmJeROneP0U82QYC4haaK1zm5a9Hrz7tOCmUI5Xvd_UiDgqxJER1D5RYFVSq8vlzY2OvEW0eZs7p5MuRWHbwfDMAgop5tDK9QOFhfnCvE-O67pGQep8RdXSUwNfTjcVr27Bf3hif5aBNUsTE9xqnrnBnX3I7wCCniVQ2gzozS8fm9pSsPqspJCOgZAcL6tC2leBLQnVgg062HQXKSJ_dF_4_QDzBkPaUyR6Z4IlPuPFhjZu_cdOMREHE9QOMfn-rk2LE32lDhIwGmx3q-Asg8lNf_zH5ejYnn3Nd-_oU3EozhanDIHE5RQBYFg48Jy414dTckVVRX4K5dzPDqQGi0Ykqv4tch4Wf71_QvGW4W-k-lzEFCJoqVUw3GhVNdcSC504ghO9eDODbWxP23CjQ-HR86Se2HU13F4DWjvQhrt0O8zUI7Jul1kUx98xB27X8SAJdsHphjlVUASB4zVUo7EXA6X41zZbRDMGGKRIcPwG5n0L3y3ri3mqfUsvZCLUS8-6ZEzwbcdfNx4g39apojLckfX7IsddHLAwJ1omwHvr08TUcuU7nmm3oTUwEP9uqbNexwYSrqdV67tHKDE2K69wVfO-CONgj7y0qXclgP0hygpoUOpq3nGSD8F3hXKAmeMd65Yxk7N2LxbdOQQlNPq_stzdVSN2M60GUIl67NLsZ7HXuHeFPsJFNBplwxCnlH5BS0Sn88ZrdhZWQioPazQpgKmsj0fGjuSn9EVm4LxOeHssVr-APybC3Mny2-ri__j4MJxCRHQj5q6wv13kAyNe18NdvvTkStVJrFp3C4tk_eSTQQYMP6ymFdh-Yi3pgsQa7kgLotfESGZWhCyjcMqj87q2H-AnrDvn4w9AfLuGj1q4nK9KyN4Vt8FV3-beSY9tgk7zFRtntp9pPSpCVlGNcFrH2fy6pVCmPB3kqDzSsa4sXgjWKa36Zpuzfiueu53G3PDFpsSogqfYqFwFnlgVL4mUjYnQO3iy_-rZJLd8dUEMcvM-nLNNJNK7S8TiKajRPX5Nfv0BfYILbvYiEDDoetqX6Iu7k_-t9SHH-ri2Fe3zzhGX7jHDdVmavdkBA19_WhHBFZ5GUn8rTifQ4jZgJlhKA0mUWZHiEDQCXGFBhoF3sSiz-zxAMttHiwBwG9qxc7Yb3E9v3HUNSr2JbERqtuenf8tt76s9JGugcMCpLD6k7VprpYw-dgf0lqV0ZeioNIxYFwZe7S2xB3dgPdOI1fnF1Nb3ViANDO15qSAFHllzfE10g2TTCgoaq5bEuJYzw5rj_-2AzUIXz-SwsEMreP7rLhm1Qx2TvxTjTk5t6m5s2an0364WqtQnqvzK17WEAflQ5M3cndGNnbmsQUahp9wTgxCkRSXE_r4wdVJSDd54VQ6Hk6LUN7M2dtlsPRiJ9kB3ljmZACYCLqJasLgFuiT-iHQ-berfQsBQBvQUIb3law2cT5jYWioAfaHzGYLjGqfCell4781pYT_Z81fXBXR8-cP9U552WG65gYIcE8uQtRbUwkKQ8MiJ19hEkkmKAuD91wEGy-_fnuNNQdh1bMNPTw5qTlfXcRhmGIUhAk5PCVhBpF-4NkrrT4ZnfZtmWvNmTkfliQL_HCsliL6aM35li7Pfm7EHtbWy-k4jIqZNjDxHwvvZ3lpI86rUawaiwb5ukc15wZcDK2rPB5uG1E7ufwEBHmzz4eLD5dDiSk7iI1zVjZU4HyM0yrFWLCsKx6iCiovqw2QeyRKtvUl-xc8nk_Vj8VBzuaE0OgrcsZwyNalRwh7T5uWqZYYEEMZ4SG1HD6dOkFabmr3WW22kTuH__xi3WKUvE3A2ZifvNIoNNmbrV0S38NGQzo_QUsOQ6QxcIBw4wNQRrLyCLk0ctA2VXEyX5sjDG3ROd-pN4bGOnHIhH76M2n_-9YUUbQg00oihOiuVSaCkp3dtJxTQ2apA9Cy5GvcuZmX2nWou-kNLFM7KIZiP5GaeFkr2nrReCNGQSqFbVWgJQivvXgGyH2-IKRBbMDkHv6NZzNhheJJl2xg3cIu31vDeJ5sJe0CDBSn6Z_19jsZ4B6lUSkx9kddaCB2GOjc5f_TYsCFlyb4hdNrDE0qliwYQeBPVp6Ui5wwpZL_cm0eVnIneV9_hWCa6pd-PsCIRseu-agBg_Z9gGj9B4-i4tGZvLGU50gZmnHhX_IdBirg14c7YKYSAmEOnBTbmVfi2gYe_fMcKk2i6ye8drwEezSSnqlZ3h_mzUPmz8-QZZ5cCy4zxl8ggEDpdVsS5ZHOsPCFz2ExZ_ziYLHvdeIhkAcZ7xDMW3HfKyEFoEKLgaFOENtGLR7sRmnmHN1DRDoim6EpiEqGlHJoiLcIq6YwfeDdTg3ZMzujXKIrqLgLy7EQW-QEVj5tSfDuZaszdsRegrZ8HMp2bkkavZtwjPK5CL2Dniw_w36z_BTUxGv4m2s4zyYT6qlSSvOtOjnSBGLhSdTdB3U3KbSbL6bVrHQPftKqjVVKn1ztQrIKWy-nqFTS4v6v_NCSSZqEUTgFYCZPUMRpwIIhcagaWhQtdl4FjjncGEAI52-nbLfGVTNylSHB0YUXOAWGQijGI60p-bnpPzRNjobntZ5FEnVmEOePEu9S3VSVwSIUwA96x9P7voqeTspIlEVy5l6DzD4Y6DByAgbajiRMfob0VCUXtFDP0nobmqouCvQZUc-Nl3X1SoKq08u9KT9GLPPb4Ghn_aL

class BSTNode:
	
    def __init__(self, key, parent):

        self.NodeKey = key
        self.Parent = parent
        self.LeftChild = None
        self.RightChild = None
        self.Level = 0
        
class BalancedBST:
		
    def __init__(self):

    	self.Root = None

    def GenerateTree(self, a):  

        a.sort()
        tree = []

        def building(parent, a):

            if a:
                node = BSTNode(a[len(a)//2], parent)
                if parent is None:
                    node.Level = 1
                    self.Root = node
                else:
                    node.Level = parent.Level + 1
                tree.append(node)
                node.LeftChild = building(node, a[:len(a)//2])
                node.RightChild = building(node, a[len(a)//2+1:])
            else:
                return None
            return node

        building(None, a)
        return tree
        
    def IsBalanced(self, root_node):

        finder = root_node
        queue = []
        list_of_nodes = []
        queue.append(root_node)
        while finder.LeftChild or finder.RightChild:
            if finder.LeftChild:
                finder = finder.LeftChild
            if finder.RightChild:
                finder = finder.RightChild
        while queue:
            node = queue.pop(0)
            if node.Level == finder.Level - 1:
                list_of_nodes.append(node)
            if node.LeftChild:
                queue.append(node.LeftChild)
            if node.RightChild:
                queue.append(node.RightChild)
        nodes_amount = 2 ** (finder.Level - root_node.Level - 1)
        if nodes_amount == len(list_of_nodes):
            return  True
        else:
            return False
            
import unittest

class Test_BalancedBST(unittest.TestCase):

    def test_GenerateTree(self):

        def testing():

            queue = []
            test.GenerateTree(values)
            queue.append(test.Root)
            while queue:
                node = queue.pop(0)
                if node.NodeKey > node.LeftChild.NodeKey:
                    continue
                else:
                    return False
                if node.NodeKey < node.RightChild.NodeKey:
                    continue
                else:
                    return False
                if node.LeftChild:
                    queue.append(node.LeftChild)
                if node.RightChild:
                    queue.append(node.RightChild)
            return True

        result = testing()
        self.assertEqual(result, True)
        
    def test_IsBalanced(self):

        test.GenerateTree(values)
        self.assertEqual(test.IsBalanced(test.Root), True)

        def Generator(a):  

            a.sort()
            tree = []

            def building(parent, a):
              
                if a:
                    node = BSTNode(a[len(a)//2], parent)
                    if node.NodeKey == 6:
                        return
                    if parent is None:
                        node.Level = 1
                        self.Root = node
                    else:
                        node.Level = parent.Level + 1
                    tree.append(node)
                    node.LeftChild = building(node, a[:len(a)//2])
                    node.RightChild = building(node, a[len(a)//2+1:])
                else:
                    return None
                return node

            building(None, a)
            return tree

        result = Generator(values)
        root_node = result[0]
        self.assertEqual(test.IsBalanced(root_node), False)

if __name__ == '__main__':

    values = [1, 2, 3, 4, 5, 6, 7]
    test = BalancedBST()
    unittest.main(verbosity=2)
